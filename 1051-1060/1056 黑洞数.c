/*
1056: 黑洞数
时间限制: 1 Sec  内存限制: 128 MB
题目描述
黑洞数也称为陷阱数，又称“Kaprekar问题”，是一类具有奇特转换特性的数。
任何一个各位数字不全相同的三位数，经有限次“重排求差”操作，总会得到495。最后所得的495即为三位黑洞数。所谓“重排求差”操作即组成该数的数字重排后的最大数减去重排后的最小数。（6174为四位黑洞数。）
例如，对三位数207：
第1次重排求差得：720 - 27 ＝ 693；
第2次重排求差得：963 - 369 ＝ 594；
第3次重排求差得：954 - 459 ＝ 495；
以后会停留在495这一黑洞数。如果三位数的3个数字全相同，一次转换后即为0。
任意输入一个三位数，编程给出重排求差的过程。
输入
输入在一行中给出一个三位数。
输出
        按照以下格式输出重排求差的过程：
序号: 数字重排后的最大数 - 重排后的最小数 = 差值
        序号从1开始，直到495出现在等号右边为止。
样例输入
123
样例输出
1:321-123=198
2:981-189=792
3:972-279=693
4:963-369=594
5:954-459=495
*/
#include<stdio.h>
int main() {
  int n,a,b,c,k=1,t,max,min,count=0;
  scanf("%d",&n);
  while(k!=495) {
    a=n%10;/*输出每位上的数*/
    b=n/100;
    c=(n%100)/10;
    if(a>b) {t=a;a=b,b=t;}/*比较大小排序*/
    if(a>c) {t=a;a=c;c=t;}
    if(b>c) {t=b;b=c;c=t;}
    min=a*100+b*10+c;
    max=c*100+b*10+a;
    k=max-min;
    count++;
    printf("%d:%d-%d=%d\n",count,max,min,k);
    n=k;
}
  return 0;
}